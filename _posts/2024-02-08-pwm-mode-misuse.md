---
layout: post
title: 变频器制作-第11部分 pwm模式用对了吗？
tags: [变频器, 死区时间, TIM]
---

# 话说高级定时器

不管是 AT32 还是 CH32 还是 EG32 还是 GD32 还是 RP32. 各种 32 单片机，都是使用的 防STM32 的外设。

因此，他们都会有一种叫“高级定时器”的设备，用来产生多路互补PWM波。

在高级定时器的设置里，能产生的波形是以下机制的排列组合

1. 计数器模式
    向上计数溢出置0，向下计数到0重置，向上然后向下计数。后两者称为中央对称模式。在 svpwm 里，固定使用中央对称模式。

2. 通道大于占空比值输出真，大于占空比值输出假。
3. 真值高电平 真值为低电平

有些hal库，上管通道和下管通道可以分别设置 2 号模式。有些没有独立设置。不知道是硬件如此还是hal库认为没必要暴露这种设定。

2 号 和3 号设定，有互补性。比如 （通道大于占空比值输出真+真值高电平）和 （大于占空比值输出假+真值为低电平）的组合，产生的 pwm 波是一模一样的。

一开始，我并没有在意，感觉是硬件上可能会做一些没有意义的组合机制。比如 三个上管打开和3个下管同时打开，作用是一样的，在 svpwm 里都是属于0向量。

# 再谈死区时间

最初我制作12v的低压变频器的时候，并没有在单片机里设定死区时间。因为栅极驱动已经内置了一个死区时间。

6pwm 模式相比 3pwm 模式，死区可调的优势当时我是不知道的。我只不过是希望能有6管同时关闭的模式。所以即使不需要死区控制，我也使用了6pwm 模式。

直到后来，我开始向220v进发。高压 MOS 相比低压 MOS 具有更大的导通和关断延迟。栅极驱动里默认的延迟时间显得不太够用了。

由此，6pwm 模式软件可调死区的优势就是必须的了。

在设定一个死区时间后，我就上机调试了。发现电路能正常运行，并且没有炸鸡。我以为大功告成了。

然而，我的眼花悄悄的给我开起了玩笑。

# 被pwm模式的的排列组合暴击

之前讲过，（通道大于占空比值输出真+真值高电平）和 （大于占空比值输出假+真值为低电平）的组合，产生的 pwm 波形是一样的。

事实上，我确实就随意的选了一种模式，并且当时恰好能工作。

其实，这个结论，只有不使用死区控制的时候是正确的。 使用了死区控制，结论就不正确了。
因为，这关系到，单片机在输出死区这段时间，是上下管的 pwm 波同时高电平，还是同时低电平。

而且我恰好把这个设置弄反了。结果就是，单片机在死区时间，输出模式乃上下管同时高电平。

而栅极驱动确实尽职尽责。在单片机输出上下同开的错误命令的时候，检测到了错误，忠实的完成了自己的“防上下管同开”的任务。于是恰好，没有炸管。

但是突然有那么一个瞬间，栅极驱动不灵了。他未能完成他的任务。上下管同时导通了！

于是，2个470uF 的滤波电容正极到上管的漏极，这条 PCB 布线被炸断。MOS管自身也在短路电流下炸毁。由于短路是发生在滤波电容上，空开还未来得及动作，PCB布线炸毁导致回路切断。所以空开没有任何反应。只听到滋的一声，MOS亮了以下。然后就没然后了。

# 总结

经过重新编写的 pwm 驱动，终于没有暴击了。单片机高级定时器的这些灵活设计其实也是非常好的。比如光耦版本的高压驱动板上，我就必须设定真值为低电平。因为经过光耦的信号会反相。用单片机的 gpio 术语来说，就是光耦的输出端是开漏的。输入高电平，让内部光敏二极管导通，拉低输出端口电压。因此光耦反相，如果不想多花钱将光耦的输出再次反相，就可以在单片机端设定 pwm 输出信号真值为低电平。这样灵活的设计怎么能怪它坑人呢。 ^_^

