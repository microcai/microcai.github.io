---
layout: post
title: 制作变频器-第一部分
tags: [变频器, SVPWM, PWM]
---

为了验证，我决定亲自设计一款三相电源。这个电源可以随意设定电压和频率。

三相电源，在任意时刻，可以由2个参数唯一确定： 电压/角度。
这个电压，指的是完整周期的相电压。因为三相的角度各相差120度。所以确定一个相的相位，就能自动推出另外2个相位。

因此，在三相电源的核心逆变代码，只参考由上层传入的两个控制参数：电压和角度。

有了角度，就可以知道任意相，他相对直流母线的电压因为 (sin(角度) /2 + 0.5)*电压。另外两相各加120度和240度即可。
如果把 电压设定为 0-1 之间的一个比例，也就是相对直流母线的电压，则算出来的值，就是每相的 上下管的导通之比。

算出三相的PWM之比后，只要 mcu 设定为 中央对齐的 PWM 输出，就可以完美的输出指定角度的三相电了。

然后再利用定时器，不断的更新 角度变量，就可以输出周期变化的三相交流电了。

```cpp

auto U_a = sin((electron_angle + 0.0) / 180.0 * pi) / 2.0 + 0.5;
auto U_b = sin((electron_angle + 120.0) / 180.0 * pi) / 2.0 + 0.5;
auto U_c = sin((electron_angle + 240.0) / 180.0 * pi) / 2.0 + 0.5;

U_a *= throttle;
U_b *= throttle;
U_c *= throttle;

pwm_set_duty(U_a, U_b, U_c);

```

pwm 输出必须为中央对齐。可以大大降低开关损失。

electron_angle 的更新，可以放到 定时器里，也可以放到 pwm 的中断响应里。

electron_angle 的更新步进为，频率/pwm周期，如果 pwm 周期设定为 频率的整数倍 S，那么 electron_angle 的更新步进就是 360°C/S。


每个pwm周期要执行三次 sin 运算。但是根据 三相和为 0 ，可以省去一个 sin 计算。简化为

```cpp
auto U_a = sin((electron_angle + 0.0) / 180.0 * pi) / 2.0 + 0.5;
auto U_b = sin((electron_angle + 120.0) / 180.0 * pi) / 2.0 + 0.5;
auto U_c = 1.5 - U_a - U_b;

```

即使不使用 clarke 变换，也只要每周期执行2次三角函数。


11 月 29 日更新：

直接按 sin 值幅值给 pwm 占空比是不行的。需要进行一定的变化。不过确实不需要 clarke 变换就是了。

还是根据六步换向法，确定扇区后，再根据 sin 值进行 pwm 占空比赋值。在每个扇区，必有一相是低端管持续开启的。

次年 1月 20 日更新：

能用，之前的代码其实没有错误。是pwm驱动的bug所以匆忙下了错误的结论。

```cpp
// 本函数通过 电角度 和 油门大小，直接算出输出的pwm波.
// 无需 Uq 和 Ud 进行反 clarke 变换.
// 如需进行 FOC 控制，可以测量功率因素（电流相比电压的滞后相位），直接对电角度进行提前
// 因此 FOC 控制也只需调制 electron_angle_ 和 throttle
std::tuple<float_number, float_number, float_number> svpwm::caculate_spwm() const
{
    static const float_number half{0.5};
    static const float_number one_half{1.5};

    // 计算三个 [0,1] 区间的正弦值。相位依次差 120°
    // 由于三相的和为 1.5，所以 C 相可以直接减法得出，不用多调用一次 sin
    float_number U_a = sin_of_degree(electron_angle_)/2		 + half;
    float_number U_b = sin_of_degree(electron_angle_ + 120)/2 + half;
    float_number U_c = one_half - U_a - U_b;

    // 将计算结果和油门(0,100%)大小相乘，就得出了三相各自的 pwm 占空比
    return std::make_tuple(U_a* throttle, U_b* throttle, U_c* throttle);
}
```

这个代码已经在我的变频器上验证通过。完全可行。

次次年更新：

其实之前的做法算出来的是 SPWM 调制，如果要提高母线电压利用率，可以使用中点偏移法移动中点电位，实现馒头波调制。

代码如下：

```cpp
std::tuple<float_number, float_number, float_number> svpwm::caculate_spwm() const
{
    // find the sector we are in currently
    int sector = static_cast<int>(electron_angle / 120);
    static const float_number sector_angle[]
        = { float_number(0), float_number(120), float_number(240), float_number(360) };

    auto angle_in_sector = electron_angle - sector_angle[sector];

    float_number T1 = Uout * sin_of_degree(120 - angle_in_sector);
    float_number T2 = Uout * sin_of_degree(angle_in_sector);

    float_number Tmax;

    if (angle_in_sector > 60)
        Tmax = T2;
    else
        Tmax = T1;

    // 中点漂移法
    float_number center = (float_number{ 1 } - Tmax) / 2;

    float_number U_a, U_b, U_c;
    switch (sector)
    {
        case 0:
            U_a = T1;
            U_b = T2;
            U_c = 0;
            break;
        case 1:
            U_a = 0;
            U_b = T1;
            U_c = T2;
            break;
        case 2:
            U_a = T2;
            U_b = 0;
            U_c = T1;
            break;
    }

    U_a += center;
    U_b += center;
    U_c += center;

    return std::make_tuple(U_a, U_b, U_c);
}


```

